Fichero: dev/stxt/Constants.java
```
package dev.stxt;

import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

class Constants {
	public static final char COMMENT_CHAR	= '#';
	public static final int TAB_SPACES 		= 4;
	public static final char TAB 			= '\t';
	public static final char SPACE 			= ' ';
	public static final char SEP_NODE 		= ':';
	public static final Charset ENCODING	= StandardCharsets.UTF_8;
	public static final String EMPTY_NAMESPACE = "";
}

```

Fichero: dev/stxt/exceptions/LineAwareException.java
```
package dev.stxt.exceptions;

public abstract class LineAwareException extends STXTException {
	private static final long serialVersionUID = 1L;
	
	private final int line;
    
    protected LineAwareException(int line, String code, String message) {
        super(code, "Error at line: " + line + ", " + message);
        this.line = line;
    }
    
    public int getLine() { return line; }
}

```

Fichero: dev/stxt/exceptions/ParseException.java
```
package dev.stxt.exceptions;

public class ParseException extends LineAwareException {
	private static final long serialVersionUID = 1L;
	
    public ParseException(int line, String code, String message) {
        super(line, code, message);
    }
}

```

Fichero: dev/stxt/exceptions/ResourceNotFoundException.java
```
package dev.stxt.exceptions;

public class ResourceNotFoundException extends STXTException {
	private static final long serialVersionUID = 1L;

	private final String namespace;
	private final String resource;

	public ResourceNotFoundException(String namespace, String resource) {
		super("RESOURCE_NOT_FOUND", "Not found '" + resource + "' in namespace: " + namespace);
		this.namespace = namespace;
		this.resource = resource;
	}

	public String getNamespace() {
		return namespace;
	}

	public String getResource() {
		return resource;
	}
}

```

Fichero: dev/stxt/exceptions/SchemaException.java
```
package dev.stxt.exceptions;

public class SchemaException extends STXTException {
    private static final long serialVersionUID = 1L;

	public SchemaException(String code, String message) {
        super(code, message);
    }
}

```

Fichero: dev/stxt/exceptions/STXTException.java
```
package dev.stxt.exceptions;

public class STXTException extends RuntimeException {
	
	private static final long serialVersionUID = 1L;
	private final String code;
    
    public STXTException(String code, String message) {
        super(message);
        this.code = code;
    }
    
    public STXTException(String code, String message, Throwable cause) {
        super(message, cause);
        this.code = code;
    }
    
    public String getCode() { return code; }
    
    @Override
    public String toString() {
        String className = getClass().getSimpleName();
        String message = getLocalizedMessage();
        return (className + "[" + code + "]" + (message != null ? ": " + message : ""));
    }
}

```

Fichero: dev/stxt/exceptions/STXTIOException.java
```
package dev.stxt.exceptions;

public class STXTIOException extends STXTException {
	private static final long serialVersionUID = 1L;

    public STXTIOException(java.io.IOException cause) {
        super("IO_ERROR", "I/O error: " + cause.getMessage(), cause);
    }
}

```

Fichero: dev/stxt/exceptions/ValidationException.java
```
package dev.stxt.exceptions;

public class ValidationException extends ParseException {
	private static final long serialVersionUID = 1L;
	
	public ValidationException(int line, String code, String message) {
        super(line, code, message);
    }
}

```

Fichero: dev/stxt/LineIndent.java
```
package dev.stxt;

class LineIndent {
	// Indentation mode constants
	public final int indentLevel;
	public final String lineWithoutIndent;

	public LineIndent(int level, String line) {
		this.indentLevel = level;
		this.lineWithoutIndent = line;
	}
}

```

Fichero: dev/stxt/LineIndentParser.java
```
package dev.stxt;

import static dev.stxt.Constants.SPACE;
import static dev.stxt.Constants.TAB;
import static dev.stxt.Constants.TAB_SPACES;
import static dev.stxt.utils.StringUtils.rightTrim;

import dev.stxt.exceptions.ParseException;

class LineIndentParser {
	// -------------------------------------------------
	// parseLine
	// -------------------------------------------------

	public static LineIndent parseLine(String line, int numLine, ParseState parseState) {
		int stackSize = parseState.getStack().size();
		boolean lastNodeText = stackSize > 0 && parseState.getStack().peek().isTextNode();

		// Empty line
		if (line.trim().isEmpty()) {
			if (lastNodeText)
				return new LineIndent(stackSize, "");
			else
				return null;
		}

		// Recorremos
		int level = 0;
		int spaces = 0;
		int pointer = 0;

		while (pointer < line.length()) {
			char c = line.charAt(pointer);

			if (c == SPACE) {
				spaces++;
				if (spaces == TAB_SPACES) {
					level++;
					spaces = 0;
				}
			} else if (c == TAB) {
				level++;
				spaces = 0;
			} else {
				// Primer carácter no espacio/tab → fin de indentación
				break;
			}

			pointer++;

			// Dentro de multilínea: no consumir más niveles de los del nodo
			if (lastNodeText && level >= stackSize) {
				return new LineIndent(level, rightTrim(line.substring(pointer)));
			}
		}

		// Comment
		if (isCommentLine(line))
			return null;

		// Strange indentation
		if (spaces > 0)
			throw new ParseException(numLine, "INVALID_NUMBER_SPACES", "There are " + spaces + " spaces before node");

		// 4) Caso general: devolver la línea sin la indentación consumida
		return new LineIndent(level, line.substring(pointer).trim());
	}

	private static boolean isCommentLine(String line) {
		return line.trim().startsWith("#");
	}
}

```

Fichero: dev/stxt/NameNamespace.java
```
package dev.stxt;

public final class NameNamespace {
    private final String name;
    private final String namespace;

    public NameNamespace(String name, String namespace) {
        this.name = name;
        this.namespace = namespace;
    }

    public String getName() {
        return name;
    }

    public String getNamespace() {
        return namespace;
    }
}

```

Fichero: dev/stxt/NameNamespaceParser.java
```
package dev.stxt;

import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import dev.stxt.exceptions.ParseException;

public final class NameNamespaceParser {

    /**
     * Acepta:
     *   - "nombre"
     *   - "nombre (namespace)"
     *
     * nombre:
     *   - letras Unicode (acentos incluidos), números, espacios, '_' y '-'
     *   - no se permiten otros símbolos ni paréntesis
     *
     * namespace (opcional, al final):
     *   - opcional '@' al inicio
     *   - segmentos separados por '.'
     *   - cada segmento: [a-z0-9]+ (ASCII, minúsculas)
     *
     * Nota: el namespace se parsea case-insensitive pero se normaliza a minúsculas.
     */
    private static final String NAME_TOKEN = "[\\p{L}\\p{M}\\p{N}_-]+";
    private static final String NAME_PART  = NAME_TOKEN + "(?:\\s+" + NAME_TOKEN + ")*";

    private static final String NS_SEGMENT = "[a-z0-9]+";
    private static final String NAMESPACE  = "@?" + NS_SEGMENT + "(?:\\." + NS_SEGMENT + ")*";

    private static final Pattern LINE_PATTERN = Pattern.compile(
            "^\\s*(?<name>" + NAME_PART + ")(?:\\s*\\(\\s*(?<ns>" + NAMESPACE + ")\\s*\\))?\\s*$",
            Pattern.UNICODE_CHARACTER_CLASS | Pattern.CASE_INSENSITIVE
    );

    private NameNamespaceParser() {
        // utility
    }

    public static NameNamespace parse(String rawName, String inheritedNs, int lineNumber, String fullLine) {
        if (rawName == null) {
            throw new ParseException(lineNumber, "INVALID_LINE", "Line not valid: " + fullLine);
        }

        Matcher m = LINE_PATTERN.matcher(rawName);
        if (!m.matches()) {
            throw new ParseException(lineNumber, "INVALID_NAMESPACE_DEF", "Line not valid: " + fullLine);
        }

        String name = m.group("name");
        if (name == null || name.isBlank()) {
            throw new ParseException(lineNumber, "INVALID_LINE", "Line not valid: " + fullLine);
        }

        String namespace = (inheritedNs != null) ? inheritedNs : Constants.EMPTY_NAMESPACE;

        String explicitNs = m.group("ns");
        if (explicitNs != null && !explicitNs.isBlank()) {
            namespace = explicitNs.toLowerCase(Locale.ROOT);
        }

        return new NameNamespace(name, namespace);
    }
}

```

Fichero: dev/stxt/NamespaceValidator.java
```
package dev.stxt;

import java.util.regex.Pattern;

import dev.stxt.exceptions.ParseException;

public class NamespaceValidator {
	/**
	 * Valida el namespace lógico.
	 *
	 * Reglas:
	 * - Solo minúsculas, dígitos y punto.
	 * - Puede empezar opcionalmente por '@'.
	 * - Debe ser una o varias etiquetas estilo dominio separadas por '.':
	 *   etiqueta := [a-z0-9]+
	 * ejemplos válidos: "xxx", "xxx.ddd", "zzz.ttt.ooo", "@xxx", "@xxx.ddd".
	 */
	private static final Pattern NAMESPACE_FORMAT = Pattern.compile("^@?[a-z0-9]+(\\.[a-z0-9]+)*$");
	public static void validateNamespaceFormat(String namespace, int lineNumber) {
		if (namespace == null || namespace.isEmpty())
			return;

		if (!NAMESPACE_FORMAT.matcher(namespace).matches())
			throw new ParseException(lineNumber, "INVALID_NAMESPACE", "Namespace not valid: " + namespace);
	}
}

```

Fichero: dev/stxt/Node.java
```
package dev.stxt;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import dev.stxt.exceptions.ParseException;
import dev.stxt.utils.StringUtils;

public class Node {
	private final String name;
	private final String normalizedName;
	private final String namespace;
	private final boolean textNode;

	private final String value;
	private List<String> textLines = new ArrayList<>();
	private final int line;
	private final int level;
	private List<Node> children = new ArrayList<>();
	private boolean isFrozen = false;

	public Node(int line, int level, String name, String namespace, boolean textNode, String value) {
		this.level = level;
		this.line = line;
		this.name = StringUtils.compactSpaces(name);
		this.normalizedName = StringUtils.normalize(name);
		this.namespace = StringUtils.lowerCase(namespace);
		this.value = (value == null ? "" : value.trim());
		this.textNode = textNode;
		NamespaceValidator.validateNamespaceFormat(this.namespace, line);

		if (!this.value.isEmpty() && this.isTextNode())
			throw new IllegalArgumentException("Not empty value with textNode");
		
		if (this.normalizedName.isEmpty()) {
		    throw new ParseException(line, "INVALID_NODE_NAME", "Node name not valid: " + name);
		}
	}

	public void addTextLine(String line) {
		this.textLines.add(line);
	}

	public String getName() {
		return name;
	}

	public String getNormalizedName() {
		return normalizedName;
	}

	public String getQualifiedName() {
		return namespace.isEmpty() ? normalizedName : namespace + ":" + normalizedName;
	}

	public String getNamespace() {
		return namespace;
	}

	public List<Node> getChildren() {
		return Collections.unmodifiableList(children);
	}
	
	void addChild(Node node) {
		children.add(node);
	}

	public String getValue() {
		return value;
	}

	public List<String> getTextLines() {
		return textLines;
	}

	public int getLine() {
		return line;
	}

	public int getLevel() {
		return level;
	}

	public boolean isTextNode() {
		return textNode;
	}

	public String getText() {
		if (isTextNode())
			return String.join("\n", textLines);
		else
			return value;
	}

	public void freeze()
	{
		if (isFrozen) return;
		for (Node n: children) n.freeze();
		this.children = Collections.unmodifiableList(this.children);
		this.textLines = Collections.unmodifiableList(this.textLines);		
		
		isFrozen = true;
	}
	
	public Node getChild(String cname) {
		List<Node> result = getChildren(cname);
		if (result.size() > 1)
			throw new IllegalArgumentException("More than 1 child. Use getChildren");
		if (result.size() == 0)
			return null;
		return result.get(0);
	}

	// Fast access methods to children
	public List<Node> getChildren(String cname) {
		String key = StringUtils.normalize(cname);
		List<Node> result = new ArrayList<Node>();

		for (Node child : children) {
			if (child.getNormalizedName().equals(key))
				result.add(child);
		}

		return result;
	}
	
	@Override
	public String toString() {
	    StringBuilder sb = new StringBuilder();
	    sb.append("Node{");
	    sb.append("line=").append(line);
	    sb.append(", level=").append(level);
	    sb.append(", name='").append(name).append('\'');
	    if (!namespace.isEmpty()) sb.append(", ns='").append(namespace).append('\'');
	    sb.append(", text=").append(textNode);
	    if (!textNode && !value.isEmpty()) sb.append(", value='").append(value).append('\'');
	    if (textNode) sb.append(", lines=").append(textLines.size());
	    sb.append(", children=").append(children.size());
	    sb.append('}');
	    return sb.toString();
	}
	
}
```

Fichero: dev/stxt/Parser.java
```
package dev.stxt;

import java.io.BufferedReader;
import java.io.File;
import java.io.StringReader;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;

import dev.stxt.exceptions.ParseException;
import dev.stxt.exceptions.STXTIOException;
import dev.stxt.processors.Observer;
import dev.stxt.processors.Validator;
import dev.stxt.utils.FileUtils;

public class Parser {
	/** 
	 *  Configuración de procesadores
	 */
	
	private List<Validator> validators;
	private List<Observer> observers;

	public void registerValidator(Validator v) {
        if (validators == null) {
            validators = new ArrayList<Validator>();
        }
        validators.add(v);
	}
	public void registerObserver(Observer o) {
        if (observers == null) {
            observers = new ArrayList<Observer>();
        }
        observers.add(o);
	}

	/** 
	 *  Parseo principal del texto
	 */
	
	public List<Node> parseFile(File srcFile) {
		try {
			return parse(FileUtils.readFileContent(srcFile));
		} catch (java.io.IOException e) {
			throw new STXTIOException(e);
		}
	}

	public List<Node> parse(String content) {
		content = FileUtils.removeUTF8BOM(content);

		ParseState state = new ParseState();
		int lineNumber = 0;

		try (BufferedReader in = new BufferedReader(new StringReader(content))) {
			String line;
			while ((line = in.readLine()) != null) {
				lineNumber++;
				processLine(line, lineNumber, state);
			}
		} catch (java.io.IOException e) {
			throw new STXTIOException(e);
		}

		// Cerrar todos los nodos pendientes al EOF
		closeToLevel(state, 0);
		
		// Retorno documentos
		return state.getDocuments();
	}

	private void processLine(String line, int lineNumber, ParseState state) {
		LineIndent lineIndent = LineIndentParser.parseLine(line, lineNumber, state);
		if (lineIndent == null)
			return;

		int currentLevel = lineIndent.indentLevel;

		ArrayDeque<Node> stack = state.getStack();
		Node lastNode = !stack.isEmpty() ? stack.peek() : null;
		boolean lastNodeText = lastNode != null && lastNode.isTextNode();

		// 1) Si estamos dentro de un nodo texto, y el nivel indica que sigue siendo texto,
		// añadimos línea de texto y no creamos nodo.
		if (lastNodeText && currentLevel >= stack.size()) {
			lastNode.addTextLine(lineIndent.lineWithoutIndent);
			return;
		}

		// 2) No se permite saltar niveles de indentación por encima de la profundidad actual
		if (currentLevel > stack.size()) {
			throw new ParseException(lineNumber, "INDENTATION_LEVEL_NOT_VALID",
					"Level of indent incorrect: " + currentLevel);
		}

		// 3) Cerramos nodos hasta el nivel actual (esto "finaliza" y adjunta al padre/documentos)
		closeToLevel(state, currentLevel);

		// 4) Creamos el nuevo nodo y lo dejamos "abierto" en la pila (NO lo adjuntamos aún)
		Node parent = stack.isEmpty() ? null : stack.peek();
		Node node = createNode(lineIndent, lineNumber, currentLevel, parent);
		
		// Pasamos a observers
		observeNode(node);

		// Añadimos a stack
		stack.push(node);
	}

	/**
	 * Cierra nodos hasta que stack.size() == targetLevel.
	 * Cada nodo cerrado pasa por: transform -> filter -> validate -> attach.
	 */
	private void closeToLevel(ParseState state, int targetLevel) {
		ArrayDeque<Node> stack = state.getStack();

		while (stack.size() > targetLevel) {
			Node completed = stack.pop();
			finishNode(completed);

			if (stack.isEmpty())	state.addDocument(completed);
			else					stack.peek().addChild(completed);
		}
	}

	/**
	 * 
	 * @param lineIndent
	 * @param lineNumber
	 * @param level
	 * @param parent
	 * @return
	 */
	private Node createNode(LineIndent lineIndent, int lineNumber, int level, Node parent) {
		final String line = lineIndent.lineWithoutIndent;
		String name = null;
		String value = null;
		boolean textNode = false;

		int nodeIndex = line.indexOf(':');
		int textIndex = line.indexOf(">>");
		
		if (nodeIndex == -1 && textIndex == -1)			throw new ParseException(lineNumber, "INVALID_LINE", "Line not valid: " + line);
		else if (nodeIndex == -1 && textIndex != -1) 	textNode = true;
		else if (nodeIndex != -1 && textIndex == -1) 	textNode = false;
		else if (nodeIndex < textIndex)					textNode = false;
		else if (nodeIndex >= textIndex)				throw new ParseException(lineNumber, "INVALID_LINE", "Line not valid: " + line);

		if (textNode) {
			name  = line.substring(0, textIndex);
			value = line.substring(textIndex + 2);
		}
		else {
			name  = line.substring(0, nodeIndex);
			value = line.substring(nodeIndex + 1);
		}

		if (textNode &&  !value.trim().isEmpty())
				throw new ParseException(lineNumber, "INLINE_VALUE_NOT_VALID", "Line not valid: " + line);

		// Namespace por defecto: heredado del padre
		NameNamespace nn = NameNamespaceParser.parse(name, parent != null ? parent.getNamespace(): null, lineNumber, line);
		name = nn.getName();
		String namespace = nn.getNamespace();
		
		// Validamos nombre
		if (name.isEmpty())
			throw new ParseException(lineNumber, "INVALID_LINE", "Line not valid: " + line);

		// Creamos nodo
		return new Node(lineNumber, level, name, namespace, textNode, value);
	}

	// -------------------------------------------
	// Métodos de validación, transformación, etc.
	// -------------------------------------------
	
	private Node observeNode(Node node) {
	    if (observers != null)
	        for (Observer o: observers)
	            o.onCreate(node);
	    
		return node;
	}
	
	private void finishNode(Node node) {
		node.freeze();
		
	    if (observers != null)
	        for (Observer o : observers)
	            o.onFinish(node);

	    if (validators != null)
	        for (Validator v : validators)
	            v.validate(node);
	}	
}

```

Fichero: dev/stxt/ParseState.java
```
package dev.stxt;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.List;

class ParseState {
	// Pila de nodos abiertos según la indentación actual.
	private final ArrayDeque<Node> stack = new ArrayDeque<Node>();

	// Lista de documentos raíz resultantes del parseo.
	private final List<Node> documents = new ArrayList<>();

	public ParseState() {
	}

	public ArrayDeque<Node> getStack() {
		return stack;
	}

	public List<Node> getDocuments() {
		return documents;
	}

	public void addDocument(Node doc) {
		documents.add(doc);
	}
}

```

Fichero: dev/stxt/processors/Observer.java
```
package dev.stxt.processors;

import dev.stxt.Node;

public interface Observer {
	void onCreate(Node node);
	void onFinish(Node node);
}

```

Fichero: dev/stxt/processors/Validator.java
```
package dev.stxt.processors;

import dev.stxt.Node;

public interface Validator {
	void validate(Node n);
}

```

Fichero: dev/stxt/resources/ResourcesLoader.java
```
package dev.stxt.resources;

public interface ResourcesLoader {
	public String retrieve(String namespace, String resource);
}

```

Fichero: dev/stxt/resources/ResourcesLoaderDirectory.java
```
package dev.stxt.resources;

import java.io.File;

import dev.stxt.exceptions.ResourceNotFoundException;
import dev.stxt.exceptions.STXTException;
import dev.stxt.exceptions.STXTIOException;
import dev.stxt.utils.FileUtils;

public class ResourcesLoaderDirectory implements ResourcesLoader {
	private final File dir;

	public ResourcesLoaderDirectory(String dir) {
		this(new File(dir));
	}

	public ResourcesLoaderDirectory(File dirResources) {
		this.dir = dirResources;
		if (!dir.exists() || !dir.isDirectory())
			throw new STXTException("RESOURCE_DIRECTORY_NOT_VALID",
					"Directory not valid: " + dir.getAbsolutePath());
	}

	@Override
	public String retrieve(String namespace, String resource) {
		// Obtenemos fichero
		File file = new File(dir, namespace + '/' + resource + ".stxt");

		// Validamos exista
		if (!file.exists() || !file.isFile())
			throw new ResourceNotFoundException(namespace, resource);

		// Retornamos valor
		try {
			return FileUtils.readFileContent(file);
		}
		catch (java.io.IOException e) {
			throw new STXTIOException(e);
		}		
	}
}

```

Fichero: dev/stxt/runtime/NodeWriter.java
```
package dev.stxt.runtime;

import java.util.List;

import dev.stxt.Node;

public final class NodeWriter {
    private NodeWriter() {}

    public enum IndentStyle {
        TABS,
        SPACES_4
    }

    public static String toSTXT(Node node) {
        return toSTXT(node, IndentStyle.TABS);
    }

    public static String toSTXT(Node node, IndentStyle style) {
        StringBuilder out = new StringBuilder(256);
        writeNode(out, node, 0, style, "");
        return out.toString();
    }

    public static String toSTXT(List<Node> docs) {
        return toSTXT(docs, IndentStyle.TABS);
    }

    public static String toSTXT(List<Node> docs, IndentStyle style) {
        StringBuilder out = new StringBuilder();
        for (int i = 0; i < docs.size(); i++) {
            if (i > 0) out.append('\n');
            writeNode(out, docs.get(i), 0, style, "");
        }
        return out.toString();
    }

    private static void writeNode(StringBuilder out, Node n, int depth, IndentStyle style, String parentNs) {
        indent(out, depth, style);

        String ns = n.getNamespace();

        out.append(n.getName());
        if (!ns.isEmpty() && !ns.equals(parentNs))
        	out.append(" (").append(ns).append(')');

        if (n.isTextNode()) {
            out.append(" >>\n");

            for (String line : n.getTextLines()) {
                indent(out, depth + 1, style);
                out.append(line).append('\n');
            }
        } else {
            out.append(":");
            String value = n.getValue();
            if (!value.isEmpty()) out.append(' ').append(value);
            out.append('\n');
        }

        for (Node child : n.getChildren()) {
            writeNode(out, child, depth + 1, style, ns);
        }
    }

    private static void indent(StringBuilder out, int depth, IndentStyle style) {
        if (depth <= 0) return;

        if (style == IndentStyle.SPACES_4) {
            for (int i = 0; i < depth; i++) 
            	out.append("    ");
        } else {
            for (int i = 0; i < depth; i++) 
            	out.append('\t');
        }
    }
}

```

Fichero: dev/stxt/runtime/STXT.java
```
package dev.stxt.runtime;

import java.util.List;

import dev.stxt.Parser;
import dev.stxt.resources.ResourcesLoader;
import dev.stxt.schema.SchemaProvider;
import dev.stxt.schema.SchemaProviderCache;
import dev.stxt.schema.SchemaProviderResources;
import dev.stxt.schema.SchemaValidator;
import dev.stxt.template.TemplateSchemaProvider;

public final class STXT {
    private STXT() {}

    public static Parser parser(ResourcesLoader loader) {
        Parser p = new Parser();
        p.registerValidator(new SchemaValidator(schemaProvider(loader)));
        return p;
    }

    public static Parser rawParser() {
        return new Parser();
    }

    public static SchemaProvider schemaProvider(ResourcesLoader loader) {
        return new SchemaProviderCache(List.of(
            new SchemaProviderResources(loader),
            new TemplateSchemaProvider(loader)
        ));
    }
}

```

Fichero: dev/stxt/schema/ChildDefinition.java
```
package dev.stxt.schema;

import dev.stxt.NamespaceValidator;
import dev.stxt.exceptions.ParseException;
import dev.stxt.utils.StringUtils;

public class ChildDefinition {
	private final String normalizedName;
	private final String name;
	private final String namespace;
	private final Integer min;
	private final Integer max;

	public ChildDefinition(String name, String namespace, Integer min, Integer max, int numLine) {
		this.name = StringUtils.compactSpaces(name);
		this.normalizedName = StringUtils.normalize(name);
		this.namespace = StringUtils.lowerCase(namespace);
		this.min = min;
		this.max = max;
		NamespaceValidator.validateNamespaceFormat(this.namespace, numLine);
		if (this.normalizedName.isEmpty()) {
		    throw new ParseException(numLine, "INVALID_NODE_NAME", "Node name not valid: " + name);
		}
	}

	public String getName() {
		return name;
	}

	public String getNormalizedName() {
		return normalizedName;
	}

	public String getNamespace() {
		return namespace;
	}

	public Integer getMin() {
		return min;
	}

	public Integer getMax() {
		return max;
	}

	public String getQualifiedName() {
		return namespace.isEmpty() ? normalizedName : namespace + ":" + normalizedName;
	}
}

```

Fichero: dev/stxt/schema/NodeDefinition.java
```
package dev.stxt.schema;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import dev.stxt.exceptions.ParseException;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.utils.StringUtils;

public class NodeDefinition {
	private final String name;
	private final String normalizedName;
	private final String type;
	private final Map<String, ChildDefinition> children = new HashMap<>();
	private final Set<String> values = new HashSet<String>();
	
	public NodeDefinition(String name, String type, int line) {
		this.name = StringUtils.compactSpaces(name);
		this.normalizedName = StringUtils.normalize(name);
		this.type = type;
		if (this.normalizedName.isEmpty()) {
		    throw new ParseException(line, "INVALID_NODE_NAME", "Node name not valid: " + name);
		}
	}
	public String getName() {
		return name;
	}
	public String getNormalizedName() {
		return normalizedName;
	}
	public String getType() {
		return type;
	}
	public Map<String, ChildDefinition> getChildren() {
		return Collections.unmodifiableMap(children);
	}
	public void addChildDefinition(ChildDefinition childDefinition) {
		String qname = childDefinition.getQualifiedName();
		if (children.containsKey(qname)) throw new SchemaException("CHILD_DEF_ALREADY_DEFINED", "Exists a previous node definition with: " + qname);
		children.put(qname, childDefinition);
	}
	public void addValue(String value) {
	    this.values.add(value);
	}
    public boolean isAllowedValue(String value) {
        if (this.values.size()==0) return true;
        return this.values.contains(value);
    }
    public Set<String> getValues() {
        return Collections.unmodifiableSet(this.values);
    }
}

```

Fichero: dev/stxt/schema/Schema.java
```
package dev.stxt.schema;

import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.Map;

import dev.stxt.NamespaceValidator;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.utils.StringUtils;

public class Schema {
	public static final String SCHEMA_NAMESPACE = "@stxt.schema";

	private Map<String, NodeDefinition> nodes = new LinkedHashMap<String, NodeDefinition>();
	private final String namespace;
	
	public Schema(String namespace, int line) {
		this.namespace = StringUtils.lowerCase(namespace);
		NamespaceValidator.validateNamespaceFormat(this.namespace, line);
	}
	
	public Map<String, NodeDefinition> getNodes() {
		return Collections.unmodifiableMap(nodes);
	}
	
	public NodeDefinition getNodeDefinition(String name) {
		return nodes.get(StringUtils.normalize(name));
	}
	
	public void addNodeDefinition(NodeDefinition nodeDefinition) {
		String qname = nodeDefinition.getNormalizedName();
		if (nodes.containsKey(qname)) throw new SchemaException("NODE_DEF_ALREADY_DEFINED", "Exists a previous node definition with: " + qname);
		nodes.put(qname, nodeDefinition);
	}
	
	public String getNamespace() {
		return namespace;
	}
}

```

Fichero: dev/stxt/schema/SchemaParser.java
```
package dev.stxt.schema;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

import dev.stxt.NameNamespace;
import dev.stxt.NameNamespaceParser;
import dev.stxt.Node;
import dev.stxt.exceptions.ParseException;
import dev.stxt.exceptions.STXTException;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.exceptions.ValidationException;

public class SchemaParser {

	public static Schema transformNodeToSchema(Node node) {
		// Node name
		String nodeName = node.getNormalizedName();
		String namespaceSchema = node.getNamespace();

		// Obtenemos name y namespace
		if (!nodeName.equals("schema") || !namespaceSchema.equals(Schema.SCHEMA_NAMESPACE)) {
			throw new SchemaException("NOT_STXT_SCHEMA",
					"Se espera schema(" + Schema.SCHEMA_NAMESPACE + ") y es " + nodeName + "(" + namespaceSchema + ")");
		}
		Schema schema = new Schema(node.getValue(), node.getLine());

		// Para validar
		Set<String> allNames = new HashSet<String>(); // Para validar que existan los childs
		
		// Obtenemos los nodos
		for (Node n : node.getChildren("node")) {
			NodeDefinition schNode = createFrom(n, schema.getNamespace());
			schema.addNodeDefinition(schNode);
			allNames.add(schNode.getNormalizedName());
		}

		// Validamos que todos los nombres estén definidos
		for (NodeDefinition schNode : schema.getNodes().values()) {
			for (ChildDefinition schChild : schNode.getChildren().values()) {
				if (schChild.getNamespace().equals(schema.getNamespace())) // Sólo validamos del mismo namespace
				{
					if (!allNames.contains(schChild.getNormalizedName()))
						throw new ValidationException(0, "CHILD_NOT_DEFINED",
								"Child " + schChild.getNormalizedName() + " not defined in " + schema.getNamespace());
				}
			}
		}

		return schema;
	}

	private static NodeDefinition createFrom(Node n, String namespace) {
		String name = n.getValue();
		String type = "INLINE";
		Node typeNode = n.getChild("type");
		if (typeNode != null) type = typeNode.getValue();

		NodeDefinition result = new NodeDefinition(name, type, n.getLine());
		
		Node children = n.getChild("children");
		if (children != null) {
			for (Node child: children.getChildren("child"))
				putChildToSchemaNode(result, child, namespace);
		}
		
		// Miramos values
		List<Node> values = n.getChildren("values");
		if (values != null && values.size()>0) {
		    if (!type.equals("ENUM")) 
		        throw new ParseException(n.getLine(), "VALUES_ONLY_SUPPORTED_BY_ENUM", "Values only supported for type ENUM, not for type " + type);
		    
		    if (values.size()>1)
		        throw new STXTException("INVALID_SIZE_VALUES", "Unexpected number of values: " + values.size());
		    
		    Node valuesNode = values.get(0);
		    values = valuesNode.getChildren("value");
		    for (Node value: values)
		        result.addValue(value.getValue());
		}
		
		return result;
	}

	private static void putChildToSchemaNode(NodeDefinition schemaNode, Node child, String defNamespace) {
		// Obtenemos name y namespace
		NameNamespace ns = NameNamespaceParser.parse(child.getValue(), defNamespace, child.getLine(), child.getValue());
		String name = ns.getName();
		String namespace = ns.getNamespace();
		
		ChildDefinition schemaChild = new ChildDefinition(name, namespace, getInteger(child, "min"), getInteger(child, "max"), child.getLine());
		schemaNode.addChildDefinition(schemaChild);
	}

	private static Integer getInteger(Node node, String name) {
		Node n = node.getChild(name);
		if (n == null) return null;
		
		try
		{
			return Integer.parseInt(n.getValue());
		}
		catch (Exception e)
		{
			throw new ParseException(node.getLine(), "INVALID_INTEGER", "Integer not valid: " + n.getValue());
		}
	}
}
```

Fichero: dev/stxt/schema/SchemaProvider.java
```
package dev.stxt.schema;

public interface SchemaProvider {
	public Schema getSchema(String namespace);
}

```

Fichero: dev/stxt/schema/SchemaProviderCache.java
```
package dev.stxt.schema;

import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import dev.stxt.exceptions.ResourceNotFoundException;
import dev.stxt.exceptions.SchemaException;

public final class SchemaProviderCache implements SchemaProvider {
	private final Map<String, Schema> cache = new ConcurrentHashMap<>();
	private final List<SchemaProvider> providers;
	
	public SchemaProviderCache(List<SchemaProvider> providers) {
		this.providers = providers;
	}

	public Schema getSchema(String namespace) {
		// Retorno de cache
		if (namespace == null || namespace.isEmpty())
		    throw new SchemaException("NAMESPACE_REQUIRED", "Namespace is required to load schema");
		
		namespace = namespace.toLowerCase(Locale.ROOT);
		Schema cached = cache.get(namespace);
		if (cached != null)
			return cached;

		// Cargamos schema
		Schema result = null;
		
		for (SchemaProvider provider: providers) {
			try {
				result = provider.getSchema(namespace);
				if (result != null) break;
			}
			catch (ResourceNotFoundException e) {
			}
		}
		
		if (result == null)
			throw new SchemaException("NOT_FOUND_SCHEMA", "Not found schema " + namespace);
		
		// Insertamos en cache
		cache.put(namespace, result);
		return result;
	}
}

```

Fichero: dev/stxt/schema/SchemaProviderMeta.java
```
package dev.stxt.schema;

import java.util.List;

import dev.stxt.Node;
import dev.stxt.Parser;
import dev.stxt.exceptions.ResourceNotFoundException;
import dev.stxt.exceptions.SchemaException;

public final class SchemaProviderMeta implements SchemaProvider {
	private static final String META_TEXT = "Schema (@stxt.schema): @stxt.schema\n"
	        + "    Node: Schema\n"
	        + "        Children:\n"
	        + "            Child: Description\n"
	        + "                Max: 1\n"
	        + "            Child: Node\n"
	        + "                Min: 1\n"
	        + "    Node: Node\n"
	        + "        Children:\n"
	        + "            Child: Type\n"
	        + "                Max: 1\n"
	        + "            Child: Children\n"
	        + "                Max: 1\n"
	        + "            Child: Description\n"
	        + "                Max: 1\n"
	        + "            Child: Values\n"
	        + "                Max: 1\n"
	        + "    Node: Children\n"
	        + "        Children:\n"
	        + "            Child: Child\n"
	        + "                Min: 1\n"
	        + "    Node: Description\n"
	        + "        Type: TEXT\n"
	        + "    Node: Child\n"
	        + "        Children:\n"
	        + "            Child: Min\n"
	        + "                Max: 1\n"
	        + "            Child: Max\n"
	        + "                Max: 1\n"
	        + "    Node: Min\n"
	        + "        Type: NATURAL\n"
	        + "    Node: Max\n"
	        + "        Type: NATURAL\n"
	        + "    Node: Type\n"
	        + "    Node: Values\n"
	        + "        Children:\n"
	        + "            Child: Value\n"
	        + "                Min: 1\n"
	        + "    Node: Value";
	
	private final Schema meta;

	public SchemaProviderMeta() {
		Schema metaSchema = null;
		Parser parser = new Parser();
		List<Node> nodes = parser.parse(META_TEXT);
		if (nodes.size() != 1)
		    throw new SchemaException("META_SCHEMA_INVALID", "Meta schema must produce exactly 1 document, got " + nodes.size());
		metaSchema = SchemaParser.transformNodeToSchema(nodes.get(0));
		meta = metaSchema;
	}

	public Schema getSchema(String namespace) {
	    if (!Schema.SCHEMA_NAMESPACE.equals(namespace))
	        throw new ResourceNotFoundException(Schema.SCHEMA_NAMESPACE, namespace);

	    if (meta == null)
	        throw new SchemaException("META_SCHEMA_NOT_AVAILABLE", "Meta schema not available");

	    return meta;
	}
}

```

Fichero: dev/stxt/schema/SchemaProviderResources.java
```
package dev.stxt.schema;

import java.util.List;
import java.util.Locale;

import dev.stxt.Node;
import dev.stxt.Parser;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.resources.ResourcesLoader;

public final class SchemaProviderResources implements SchemaProvider {
	private final ResourcesLoader resourcesLoader;
	private final SchemaValidator schemaValidator;

	public SchemaProviderResources(ResourcesLoader pathResolver) {
		this.resourcesLoader = pathResolver;
		this.schemaValidator = new SchemaValidator(new SchemaProviderMeta());
	}

	public Schema getSchema(String namespace) {
		// Retorno de cache
		if (namespace == null || namespace.isEmpty())
		    throw new SchemaException("NAMESPACE_REQUIRED", "Namespace is required to load schema");
		
		namespace = namespace.toLowerCase(Locale.ROOT);

		// Cargamos schema
		String textSchema = resourcesLoader.retrieve(Schema.SCHEMA_NAMESPACE, namespace);
		Parser parser = new Parser();
		parser.registerValidator(schemaValidator);
		List<Node> nodes = parser.parse(textSchema);

		if (nodes.size() != 1)
			throw new SchemaException("INVALID_SCHEMA", "There are " + nodes.size() + ", and expected is 1");

		// Convertimos a schema
		Node root = nodes.get(0);
		Schema sch = SchemaParser.transformNodeToSchema(root);

		// Comprobar namespace esperado
		if (!sch.getNamespace().equalsIgnoreCase(namespace))
			throw new SchemaException("INVALID_SCHEMA", "Schema namespace is " + sch.getNamespace() + ", and expected is " + namespace);

		// Insertamos en cache
		return sch;
	}
}

```

Fichero: dev/stxt/schema/SchemaValidator.java
```
package dev.stxt.schema;

import java.util.HashMap;
import java.util.Map;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.processors.Validator;

public class SchemaValidator implements Validator {
	private final SchemaProvider schemaProvider;
	private boolean recursiveValidation = false;

	public SchemaValidator(SchemaProvider schemaProvider) {
		this.schemaProvider = schemaProvider;
	}
	public SchemaValidator(SchemaProvider schemaProvider, boolean recursive) {
		this.schemaProvider = schemaProvider;
		this.recursiveValidation = recursive;
	}

	@Override
	public void validate(Node node) {
		// Obtenemos namespace
		String namespace = node.getNamespace();
		Schema sch = schemaProvider.getSchema(namespace);
		if (sch == null)
			throw new ValidationException(node.getLine(), "SCHEMA_NOT_FOUND", "Not found schema: " + namespace);

		// Validamos nodo
		validateAgainstSchema(node, sch);
		
		// Validamos children
		if (recursiveValidation)
			for (Node n: node.getChildren())
				validate(n);
	}
	
	public void validateAgainstSchema(Node node, Schema sch) {
	    NodeDefinition schemaNode = sch.getNodeDefinition(node.getNormalizedName());
	    if (schemaNode == null) {
	        String error = "NOT EXIST NODE " + node.getNormalizedName() + " for namespace " + sch.getNamespace();
	        throw new ValidationException(node.getLine(), "NODE_NOT_EXIST_IN_SCHEMA", error);
	    }

	    validateValue(schemaNode, node);
	    validateCount(schemaNode, node);
	}

	private static void validateValue(NodeDefinition nsNode, Node n) {
		String nodeType = nsNode.getType();

		Type validator = TypeRegistry.get(nodeType);
		if (validator == null)
			throw new ValidationException(n.getLine(), "TYPE_NOT_SUPPORTED", "Node type not supported: " + nodeType);

		validator.validate(nsNode, n);
	}

	private static void validateCount(NodeDefinition nsNode, Node node) {
		Map<String, Integer> count = new HashMap<>();

		for (Node child : node.getChildren()) {
			// Count childs
			String childName = child.getQualifiedName();
			count.put(childName, count.getOrDefault(childName, 0) + 1);
		}

		for (ChildDefinition chNode : nsNode.getChildren().values()) {
			validateCount(chNode, count.getOrDefault(chNode.getQualifiedName(), 0), node);
		}
	}

	private static void validateCount(ChildDefinition chNode, int num, Node node) {
		Integer min = chNode.getMin();
		Integer max = chNode.getMax();

		if (min != null && num < min)
			throw new ValidationException(node.getLine(), "INVALID_NUMBER",
					num + " nodes of '" + chNode.getQualifiedName() + " and min is " + min);

		if (max != null && num > max)
			throw new ValidationException(node.getLine(), "INVALID_NUMBER",
					num + " nodes of '" + chNode.getQualifiedName() + " and max is " + max);
	}

}

```

Fichero: dev/stxt/schema/type/Base64.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;
import dev.stxt.utils.StringUtils;

public final class Base64 implements Type {
	public static final Base64 INSTANCE = new Base64();

	private Base64() {
	}

	@Override
	public void validate(NodeDefinition ndef, Node n) {
		try {
			java.util.Base64.getDecoder().decode(StringUtils.cleanSpaces(n.getText()));
		} catch (Exception e) {
			throw new ValidationException(n.getLine(), "INVALID_VALUE", "Node '" + n.getName() + "' Invalid Base64");
		}
	}

	@Override
	public String getName() {
		return "BASE64";
	}
}

```

Fichero: dev/stxt/schema/type/Block.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Block implements Type {
	public static final Block INSTANCE = new Block();

	private Block() {
	}

	@Override
	public String getName() {
		return "BLOCK";
	}
	
	@Override
    public void validate(NodeDefinition ndef, Node n) {
		if (!n.getValue().isEmpty()) {
			throw new ValidationException(n.getLine(), "NOT_ALLOWED_VALUE",
					"Not allowed inline text in node " + n.getQualifiedName());
		}
	}

}

```

Fichero: dev/stxt/schema/type/Boolean.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Boolean extends RegexValue {
	private static final Pattern P_BOOLEAN = Pattern.compile("^(true|false)$");
	public static final Boolean INSTANCE = new Boolean();

	private Boolean() {
		super(P_BOOLEAN, "Invalid boolean");
	}

	@Override
	public String getName() {
		return "BOOLEAN";
	}
}

```

Fichero: dev/stxt/schema/type/Date.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Date extends RegexValue {
	private static final Pattern P_DATE = Pattern.compile("^\\d{4}-\\d{2}-\\d{2}$");
	public static final Date INSTANCE = new Date();

	private Date() {
		super(P_DATE, "Invalid date");
	}

	@Override
	public String getName() {
		return "DATE";
	}
}

```

Fichero: dev/stxt/schema/type/Email.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Email extends RegexValue {
	private static final String EMAIL_PATTERN = "^(?=.{1,256})(?=.{1,64}@.{1,255}$)(?=.{1,64}@.{1,63}\\..{1,63}$)[A-Za-z0-9!#$%&'*+/=?^_`{|}~.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$";
	private static final Pattern P_EMAIL = Pattern.compile(EMAIL_PATTERN);

	public static final Email INSTANCE = new Email();

	private Email() {
		super(P_EMAIL, "Invalid email");
	}

	@Override
	public String getName() {
		return "EMAIL";
	}
}

```

Fichero: dev/stxt/schema/type/Enum.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Enum implements Type {
	public static final Enum INSTANCE = new Enum();

	private Enum() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		if (n.getTextLines().size() > 0) {
			throw new ValidationException(n.getLine(), "NOT_ALLOWED_TEXT",
					"Not allowed text in node " + n.getQualifiedName());
		}
		
		if (!ndef.getValues().contains(n.getValue()))
		    throw new ValidationException(n.getLine(), "INVALID_VALUE", "The value '" + n.getValue() + "' not allowed. Only: " + ndef.getValues());
	}

	@Override
	public String getName() {
		return "ENUM";
	}
}

```

Fichero: dev/stxt/schema/type/Group.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Group implements Type {
	public static final Group INSTANCE = new Group();

	private Group() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		if (!n.getValue().isEmpty() || n.getTextLines().size() > 0) {
			throw new ValidationException(n.getLine(), "INVALID_VALUE", "Node '" + n.getName() + "' has to be empty");
		}
	}

	@Override
	public String getName() {
		return "GROUP";
	}
}

```

Fichero: dev/stxt/schema/type/Hexadecimal.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;
import dev.stxt.utils.StringUtils;

public final class Hexadecimal implements Type {
	public static final Hexadecimal INSTANCE = new Hexadecimal();

	private Hexadecimal() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		// Elimina espacios, tabs y saltos de línea
		String value = StringUtils.cleanSpaces(n.getText());

		if (value.isEmpty()) {
			throw invalid(n, "Invalid hexadecimal (empty)");
		}

		// Permitir prefijo '#'
		if (value.startsWith("#")) {
			value = value.substring(1);
		}

		if (value.isEmpty()) {
			throw invalid(n, "Invalid hexadecimal (only '#')");
		}

		// Longitud par (hexadecimal por bytes)
		if ((value.length() & 1) != 0) {
			throw invalid(n, "Invalid hexadecimal length (must be even)");
		}

		// Validar caracteres hexadecimales
		for (int i = 0; i < value.length(); i++) {
			char c = value.charAt(i);
			if (Character.digit(c, 16) == -1) {
				throw invalid(n, "Invalid hexadecimal character '" + c + "'");
			}
		}
	}

	private static ValidationException invalid(Node n, String msg) {
		return new ValidationException(
				n.getLine(),
				"INVALID_VALUE",
				n.getName() + ": " + msg
		);
	}

	@Override
	public String getName() {
		return "HEXADECIMAL";
	}
}

```

Fichero: dev/stxt/schema/type/Inline.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Inline implements Type {
	public static final Inline INSTANCE = new Inline();

	private Inline() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		if (n.getTextLines().size() > 0) {
			throw new ValidationException(n.getLine(), "NOT_ALLOWED_TEXT",
					"Not allowed text in node " + n.getQualifiedName());
		}
	}

	@Override
	public String getName() {
		return "INLINE";
	}
}

```

Fichero: dev/stxt/schema/type/Integer.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Integer extends RegexValue {
	private static final Pattern P_INTEGER = Pattern.compile("^(\\-|\\+)?\\d+$");
	public static final Integer INSTANCE = new Integer();

	private Integer() {
		super(P_INTEGER, "Invalid integer");
	}

	@Override
	public String getName() {
		return "INTEGER";
	}
}

```

Fichero: dev/stxt/schema/type/Natural.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Natural extends RegexValue {
	private static final Pattern P_NATURAL = Pattern.compile("^\\d+$");
	public static final Natural INSTANCE = new Natural();

	private Natural() {
		super(P_NATURAL, "Invalid natural");
	}

	@Override
	public String getName() {
		return "NATURAL";
	}
}

```

Fichero: dev/stxt/schema/type/Number.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Number extends RegexValue {
    // Acepta:
    //  - 12, -12, +12
    //  - 12.34, 12., .34
    //  - 1e10, 1E10, -1.2e-3, .5e+2
    private static final Pattern P_NUMBER = Pattern.compile(
            "^[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE][+-]?\\d+)?$"
    );

    public static final Number INSTANCE = new Number();

    private Number() {
        super(P_NUMBER, "Invalid number");
    }

	@Override
	public String getName() {
		return "NUMBER";
	}
}

```

Fichero: dev/stxt/schema/type/RegexValue.java
```
package dev.stxt.schema.type;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

/**
 * Base validator for simple regex-based value checks.
 */
abstract class RegexValue implements Type {
	private final Pattern pattern;
	private final String error;

	protected RegexValue(Pattern pattern, String error) {
		this.pattern = pattern;
		this.error = error;
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		String value = n.getText();
		Matcher m = pattern.matcher(value);
		if (!m.matches()) {
			throw new ValidationException(n.getLine(), "INVALID_VALUE", n.getName() + ": " + error + " (" + value + ")");
		}
	}
}

```

Fichero: dev/stxt/schema/type/Text.java
```
package dev.stxt.schema.type;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Text implements Type {
	public static final Text INSTANCE = new Text();

	private Text() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		if (n.getChildren().size() > 0) {
			throw new ValidationException(n.getLine(), "NOT_ALLOWED_CHILDREN_TEXT",
					"Not allowed children nodes in node " + n.getQualifiedName());
		}
	}

	@Override
	public String getName() {
		return "TEXT";
	}
}

```

Fichero: dev/stxt/schema/type/Timestamp.java
```
package dev.stxt.schema.type;

import java.util.regex.Pattern;

public final class Timestamp extends RegexValue {
	private static final String ISO_8601_PATTERN = "^\\d{4}-\\d{2}-\\d{2}" + "T" + "\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?"
			+ "(Z|[+-]\\d{2}:\\d{2})?$";
	private static final Pattern P_TIMESTAMP = Pattern.compile(ISO_8601_PATTERN);

	public static final Timestamp INSTANCE = new Timestamp();

	private Timestamp() {
		super(P_TIMESTAMP, "Invalid timestamp");
	}

	@Override
	public String getName() {
		return "TIMESTAMP";
	}
}

```

Fichero: dev/stxt/schema/type/Url.java
```
package dev.stxt.schema.type;

import java.net.URI;
import java.net.URISyntaxException;

import dev.stxt.Node;
import dev.stxt.exceptions.ValidationException;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Type;

public final class Url implements Type {
	public static final Url INSTANCE = new Url();

	private Url() {
	}

	@Override
    public void validate(NodeDefinition ndef, Node n) {
		String url = n.getValue();
		try {
			URI uri = new URI(url);
			boolean ok = uri.getScheme() != null && uri.getHost() != null;
			if (!ok)
				throw new IllegalArgumentException();
		} catch (URISyntaxException | IllegalArgumentException e) {
			throw new ValidationException(n.getLine(), "INVALID_VALUE", "Invalid URL: " + url);
		}
	}

	@Override
	public String getName() {
		return "URL";
	}
}

```

Fichero: dev/stxt/schema/Type.java
```
package dev.stxt.schema;

import dev.stxt.Node;

public interface Type {
	void validate(NodeDefinition nsNode, Node node);
	String getName();
}

```

Fichero: dev/stxt/schema/TypeRegistry.java
```
package dev.stxt.schema;

import java.util.HashMap;
import java.util.Map;

import dev.stxt.exceptions.STXTException;
import dev.stxt.schema.type.Base64;
import dev.stxt.schema.type.Block;
import dev.stxt.schema.type.Boolean;
import dev.stxt.schema.type.Date;
import dev.stxt.schema.type.Email;
import dev.stxt.schema.type.Enum;
import dev.stxt.schema.type.Group;
import dev.stxt.schema.type.Hexadecimal;
import dev.stxt.schema.type.Inline;
import dev.stxt.schema.type.Integer;
import dev.stxt.schema.type.Natural;
import dev.stxt.schema.type.Number;
import dev.stxt.schema.type.Text;
import dev.stxt.schema.type.Timestamp;
import dev.stxt.schema.type.Url;

class TypeRegistry {
	private static final Map<String, Type> REGISTRY = new HashMap<>();

	static {
		// Tipos principales
		register(Inline.INSTANCE);
		register(Block.INSTANCE);
		
		// Subtipos
		register(Text.INSTANCE);
		register(Boolean.INSTANCE);
		register(Url.INSTANCE);
		register(Integer.INSTANCE);
		register(Natural.INSTANCE);
		register(Number.INSTANCE);
		register(Date.INSTANCE);
		register(Timestamp.INSTANCE);
		register(Email.INSTANCE);
		register(Hexadecimal.INSTANCE);
		register(Base64.INSTANCE);
		register(Group.INSTANCE);
		register(Enum.INSTANCE);
	}

	public static Type get(String nodeType) {
		return REGISTRY.get(nodeType);
	}

	private static void register(Type instance) {
		if (REGISTRY.containsKey(instance.getName()))
			throw new STXTException("DUPLICATED_TYPE", "Type already defined: " + instance.getName());
		
		REGISTRY.put(instance.getName(), instance);
	}

}

```

Fichero: dev/stxt/template/ChildLine.java
```
package dev.stxt.template;

import java.util.Arrays;

public class ChildLine {
    private final String type;
    private final Integer min;
    private final Integer max;
    private final String[] values;

    public ChildLine(String type, Integer min, Integer max, String[] values) {
		super();
		this.type = type;
		this.min = min;
		this.max = max;
		this.values = values;
	}
    
	public String getType() {
        return type;
    }
    public Integer getMin() {
    	return min;
    }
    public Integer getMax() {
    	return max;
    }
    public String[] getValues() {
        return values;
    }

	@Override
    public String toString()
    {
        StringBuilder builder = new StringBuilder();
        builder.append("ChildLine [type=");
        builder.append(type);
        builder.append(", min=");
        builder.append(min);
        builder.append(", max=");
        builder.append(max);
        builder.append(", values=");
        builder.append(Arrays.toString(values));
        builder.append("]");
        return builder.toString();
    }    
}
```

Fichero: dev/stxt/template/ChildLineParser.java
```
package dev.stxt.template;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import dev.stxt.exceptions.ParseException;

public final class ChildLineParser {

    private static final Pattern CHILD_LINE_PATTERN = Pattern.compile(
            "^\\s*" +
            "(?:\\(\\s*(?<count>[^()\\s][^)]*?)\\s*\\)\\s*)?" +
            "(?<type>[^\\[\\]()]*)?" +
            "(?:\\[\\s*(?<values>[^]]*?)\\s*\\]\\s*)?" +
            "\\s*$"
        );
    
    private ChildLineParser() {
    }

    public static ChildLine parse(String rawLine, int lineNumber) {
    	if (rawLine.trim().isEmpty())
    		return new ChildLine(null, null, null, null);
    	
        Matcher m = CHILD_LINE_PATTERN.matcher(rawLine);
        if (!m.matches()) {
            throw new ParseException(lineNumber, "INVALID_CHILD_LINE", "Line not valid: " + rawLine);
        }

        String type = m.group("type");
        if (type != null) type = type.trim();
        if (type == null || type.isEmpty()) type = null;

        String count = m.group("count");
        Integer min = null;
        Integer max = null;
        
		if (count == null || count.isEmpty() || count.equals("*")) {
			min = null;
			max = null;
		} else if (count.equals("?")) {
			min = null;
			max = 1;
		} else if (count.equals("+")) {
			min = 1;
			max = null;
		} else if (count.endsWith("+")) {
			int expectedNum = Integer.parseInt(count.substring(0, count.length() - 1));
			min = expectedNum;
			max = null;
		} else if (count.endsWith("-")) {
			int expectedNum = Integer.parseInt(count.substring(0, count.length() - 1));
			min = null;
			max = expectedNum;
		} else {
            try {
                int expectedNum = Integer.parseInt(count);
    			min = expectedNum;
    			max = expectedNum;
            } catch (NumberFormatException ex) {
                throw new ParseException(lineNumber, "INVALID_CHILD_COUNT", "Invalid count " + count + " in line: " + rawLine);
            }
		}
 
        String[] values = null;
        String valuesStr = m.group("values");
        if (valuesStr != null) {
            String[] parts = valuesStr.split(",");
            List<String> list = new ArrayList<>();
            for (String part: parts) {
                part = part.trim();
                if (!part.isEmpty()) {
                    if (list.contains(part)) 
                        throw new ParseException(lineNumber, "VALUE_DUPLICATED", "The values " + part + " is duplicated");
                    list.add(part);
                }
            }
            if (list.size()>0) {
                values = new String[list.size()];
                for (int i = 0; i<list.size(); i++)
                    values[i] = list.get(i);
            }            
        }
		
        return new ChildLine(type, min, max, values);
    }
}
```

Fichero: dev/stxt/template/MetaTemplateSchemaProvider.java
```
package dev.stxt.template;

import java.util.List;

import dev.stxt.Node;
import dev.stxt.Parser;
import dev.stxt.exceptions.ResourceNotFoundException;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.schema.Schema;
import dev.stxt.schema.SchemaProvider;

public class MetaTemplateSchemaProvider implements SchemaProvider {

	private static final String META_TEXT = "Template (@stxt.template): @stxt.template\n"
			+ "	Structure >>\n"
			+ "		Template:\n"
			+ "			Structure: (1) BLOCK";
	
	private final Schema meta;
	
	public MetaTemplateSchemaProvider() {
		Schema metaSchema = null;
		Parser parser = new Parser();
		List<Node> nodes = parser.parse(META_TEXT);
		if (nodes.size() != 1)
		    throw new SchemaException("META_SCHEMA_INVALID", "Meta schema must produce exactly 1 document, got " + nodes.size());
		
		metaSchema = TemplateParser.transformNodeToSchema(nodes.get(0));
		meta = metaSchema;
	}
	
	@Override
	public Schema getSchema(String namespace) {
		if (!"@stxt.template".equals(namespace))
			throw new ResourceNotFoundException("@stxt.template", namespace);

	    if (meta == null)
	        throw new SchemaException("META_SCHEMA_NOT_AVAILABLE", "Meta schema not available");

	    return meta;
	}	
}

```

Fichero: dev/stxt/template/TemplateParser.java
```
package dev.stxt.template;

import java.util.List;

import dev.stxt.Node;
import dev.stxt.Parser;
import dev.stxt.exceptions.ParseException;
import dev.stxt.schema.ChildDefinition;
import dev.stxt.schema.NodeDefinition;
import dev.stxt.schema.Schema;
import dev.stxt.utils.StringUtils;

public class TemplateParser {
	
	public static Schema transformNodeToSchema(Node node) {
		
		// Insertamos namespace
		Schema result = new Schema(node.getValue(), node.getLine());
		
		// Buscamos nodo structure
		Node structure = node.getChild("structure");
		if (structure == null) {
		    throw new ParseException(node.getLine(), "TEMPLATE_STRUCTURE_REQUIRED",
		        "Template must define 'Structure >>'");
		}
		
		String text = structure.getText();
		int offset = structure.getLine();
		
		// Parseamos para los nodos
		List<Node> nodes = new Parser().parse(text);
		
		// Vamos iterando todos los nodos insertando
		for (Node n: nodes)
			addToSchema(result, n, offset);
		
		// Retornamos resultado
		return result;
	}

	private static void addToSchema(Schema schema, Node node, int offset) {
		// Obtenemos nombre qualificado
		String namespace = node.getNamespace();
		String name = node.getName();
		
		// Miramos datos
		ChildLine cl = ChildLineParser.parse(node.getValue(), node.getLine() + offset);
		
		if (namespace.isEmpty()) namespace = schema.getNamespace(); // Es del template
		else {
			// Validamos type vacío
			String type = cl.getType();
			if (type != null && !type.trim().isEmpty()) 
				throw new ParseException(node.getLine() + offset, "TYPE_DEFINITION_NOT_ALLOWED", "Not allowed type definition in external namespaces");
			
			return; // No hacemos nada con creación de nodos que no son de @stxt.template!!
		}
		
		// Miramos si es nuevo y añadimos en listado
		NodeDefinition schemaNode = schema.getNodeDefinition(name);
		if (schemaNode == null) {	// Nuevo
			String type = cl.getType() == null? "INLINE": cl.getType();
			schemaNode = new NodeDefinition(node.getName(), type, node.getLine() + offset);
			schema.addNodeDefinition(schemaNode);
            String[] values = cl.getValues();
            if (values != null)
                for (String value: values)
                    schemaNode.addValue(value);
		} else {
			String type = cl.getType();
			if (!type.startsWith("@"))
				throw new ParseException(node.getLine() + offset, "NODE_DEFINED_MULTIPLE_TIMES", "Multiple node reference must start with @: " + node.getName());				
				
			type = type.substring(1);
			type = StringUtils.normalize(type);
			
			if (type.equals(node.getNormalizedName())) return; // OK Definition
			throw new ParseException(node.getLine() + offset, "NODE_REFERENCE_NOT_VALID", "Reference must be '" + "@" + node.getName() + "', not '" + type + "'");
		}
		
		// Una vez ya existe, si tiene hijos los intentamos crear.
		List<Node> childrenNode = node.getChildren();
		
		// Insertamos childs
		for (Node child: childrenNode) {
			cl = ChildLineParser.parse(child.getValue(), child.getLine() + offset);
			
			String childName = child.getName();
			String childNamespace = child.getNamespace();
			if (childNamespace.isEmpty()) childNamespace = schema.getNamespace();
			
			ChildDefinition schChild = new ChildDefinition(childName, childNamespace, cl.getMin(), cl.getMax(), child.getLine() + offset);
			schemaNode.addChildDefinition(schChild);
			
			addToSchema(schema, child, offset);
		}
	}
}

```

Fichero: dev/stxt/template/TemplateSchemaProvider.java
```
package dev.stxt.template;

import java.util.List;

import dev.stxt.Node;
import dev.stxt.Parser;
import dev.stxt.exceptions.SchemaException;
import dev.stxt.resources.ResourcesLoader;
import dev.stxt.schema.Schema;
import dev.stxt.schema.SchemaProvider;
import dev.stxt.schema.SchemaValidator;

public class TemplateSchemaProvider implements SchemaProvider {
	private final ResourcesLoader loader;
	
	public TemplateSchemaProvider(ResourcesLoader loader) {
		this.loader = loader;
	}	
	
	@Override
	public Schema getSchema(String namespace) {
		String template = loader.retrieve("@stxt.template", namespace);

		// Creamos parser
		Parser parser = new Parser();
		parser.registerValidator(new SchemaValidator(new MetaTemplateSchemaProvider()));
		
		List<Node> nodes = parser.parse(template);
		if (nodes.size() != 1)
			throw new SchemaException("INVALID_SCHEMA", "There are " + nodes.size() + ", and expected is 1");

		// Obtenemos schema
		Schema sch = TemplateParser.transformNodeToSchema(nodes.get(0)); 
		
		// Comprobar namespace esperado
		if (!sch.getNamespace().equalsIgnoreCase(namespace))
			throw new SchemaException("INVALID_SCHEMA", "Schema namespace is " + sch.getNamespace() + ", and expected is " + namespace);
		
		return sch;
	}
}

```

Fichero: dev/stxt/utils/FileUtils.java
```
package dev.stxt.utils;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.charset.StandardCharsets;

public class FileUtils {
	private static final String UTF8_BOM = "\uFEFF";
	
	private FileUtils() {
	}

	public static String removeUTF8BOM(String s) {
		if (s.startsWith(UTF8_BOM))
			s = s.substring(1);
		return s;
	}

	public static byte[] readFile(File file) throws IOException {
		try (RandomAccessFile f = new RandomAccessFile(file, "r")) {
			// Get and check length
			long longlength = f.length();
			int length = (int) longlength;
			if (length != longlength)
				throw new IOException("File size >= 2 GB");

			// Read file and return data
			byte[] data = new byte[length];
			f.readFully(data);
			return data;
		}
	}

	public static String readFileContent(File file) throws IOException {
		return new String(readFile(file), StandardCharsets.UTF_8);
	}

}
```

Fichero: dev/stxt/utils/StringUtils.java
```
package dev.stxt.utils;

import java.text.Normalizer;
import java.util.Locale;
import java.util.regex.Pattern;

public class StringUtils {
	private StringUtils() {
	}

	// Usado para nodos name>>
	public static String rightTrim(String s) {
		if (s == null)
			return "";
		int i = s.length() - 1;
		while (i >= 0 && Character.isWhitespace(s.charAt(i))) {
			i--;
		}
		return s.substring(0, i + 1);
	}

	// Usado para nodos tipo Base64 y Hex
	public static String cleanSpaces(String input) {
		return input.replaceAll("\\s+", "");
	}
	
	// Usado para normalizar namespace
	public static String lowerCase(String input) {
		if (input == null) return "";
		return input.toLowerCase(Locale.ROOT);
	}
	
	// Usados para name de los nodos
	public static String compactSpaces(String s) {
		if (s == null)
			return "";
		return s.trim().replaceAll("\\s+", " ");
	}

	private static final Pattern DIACRITICS = Pattern.compile("\\p{Mn}+");

	// Usados para name normalizado de nodos
	public static String normalize(String input) {
	    if (input == null) return "";
	    String s = input.trim();
	    if (s.isEmpty()) return "";

	    s = Normalizer.normalize(s, Normalizer.Form.NFKD);
	    s = DIACRITICS.matcher(s).replaceAll("");
	    s = s.toLowerCase(Locale.ROOT);
	    s = compactSpaces(s);
	    
	    // cualquier cosa que no sea [a-z0-9] => '-'
	    s = s.replaceAll("[^a-z0-9]+", "-");
	    
	    // trim de '-'
	    s = s.replaceAll("^-+|-+$", "");
	    return s;
	}	
}

```

