// -----------------
// Función principal
// -----------------

FUNCTION parseStxt(contenido: STRING) 
        THROWS ParseException
        RETURNS ParseState:

    state = createParseState()

    lines = split contenido por '\n'
    numLine = 1

    PARA cada rawLine EN lines:

        indent = parseLine(rawLine, numLine, state)

        SI indent != null ENTONCES
            processStructuralLine(indent, numLine, state)
        FIN SI

        numLine = numLine + 1
    FIN PARA

    RETURN state

// ---------------------
// processStructuralLine
// ---------------------


FUNCTION processStructuralLine(indent: LineIndent, numLine: INTEGER, state: ParseState)
        THROWS ParseException:

    level = indent.indentLevel
    text  = indent.lineWithoutIndent

    stack = state.stack
    stackSize = tamaño de stack

    lastNodeMultiline =
        (stackSize > 0) AND
        NodeType.isMultiline( tope(stack).type )


    // 1) Caso: seguimos dentro de un nodo TEXT (multilínea)
    SI lastNodeMultiline AND level >= stackSize ENTONCES
        textNode = tope(stack)
        AÑADIR text A textNode.text
        RETURN
    FIN SI


    // 2) Ajustar la pila según el nivel de indentación

    MIENTRAS stackSize > level HACER
        POP(stack)
        stackSize = stackSize - 1
    FIN MIENTRAS

    SI level > stackSize ENTONCES
        THROW ParseException(
            line    = numLine,
            code    = "INVALID_INDENT_LEVEL",
            message = "Indentation level cannot skip levels"
        )
    FIN SI


    // 3) Parsear "nombre (namespace opcional): valor"

    // 3.1) Buscar ':' obligatorio
    posColon = posición del primer ':' en text

    SI posColon == -1 ENTONCES
        THROW ParseException(
            line    = numLine,
            code    = "MISSING_COLON",
            message = "Missing ':' in structural line"
        )
    FIN SI

    rawName  = trim( subcadena de text desde 0 hasta posColon )
    rawValue = trim( subcadena de text desde (posColon + 1) hasta el final )

    // 3.2) Separar nombre y namespace si viene como "Nombre (namespace)"
    nombre    = rawName
    namespace = null

    SI rawName termina con ')' Y contiene '(' ENTONCES
        idxOpen = última posición de '(' en rawName

        nombre    = trim( subcadena de rawName desde 0 hasta idxOpen )
        namespace = trim( subcadena de rawName desde (idxOpen + 1) 
                          hasta longitud(rawName) - 1 )
    FIN SI


    // 4) Crear nodo y conectarlo al árbol

    node = createNode(
        line  = numLine,
        level = level,
        name  = nombre,
        value = rawValue
    )

    SI namespace != null ENTONCES
        node.namespace = namespace
    FIN SI

    node.type = NodeType.getDefaultType()   // normalmente "STRING"

    SI stack está vacío ENTONCES
        addDocument(state, node)           // nodo raíz
    SINO
        parent = tope(stack)
        AÑADIR node A parent.children
    FIN SI

    PUSH(stack, node)


